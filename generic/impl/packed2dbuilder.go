// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

// Copyright (c) 2018 Sung Pae <self@sungpae.com>
// Distributed under the MIT license.
// http://www.opensource.org/licenses/mit-license.php

package impl

import "math/bits"

// Packed2DIntBuilder is a optionally auto-growing [][]int
// builder that uses a single backing slice to reduce allocations. This is
// useful for building read-only non-rectangular 2D data.
type Packed2DIntBuilder struct {
	head, tail int
	buf        []int
	Rows       [][]int // Contains all finished rows; shares memory with buf
	autoGrow   bool
}

// NewPacked2DIntBuilder returns a new auto-growing [][]int
// builder that can accommodate at least size items.
func NewPacked2DIntBuilder(size int) *Packed2DIntBuilder {
	return NewPacked2DIntBuilderWithBuffer(
		make([]int, size),
	)
}

// NewPacked2DIntBuilderFromRows returns a new auto-growing
// [][]int builder from the provided 2D int slice.
//
// This constructor is equivalent to
//
// NewPacked2DIntBuilderWithBuffer(rows[0][:cap(rows[0])])
//
// and is intended to help provide a function interface for reusing
// a [][]int without requiring the caller to pass in a
// Packed2DIntBuilder.
//
func NewPacked2DIntBuilderFromRows(rows [][]int) *Packed2DIntBuilder {
	if cap(rows) == 0 {
		return NewPacked2DIntBuilderWithBuffer(nil)
	}
	buf := rows[:1][0]
	return NewPacked2DIntBuilderWithBuffer(buf[:cap(buf)])
}

// NewPacked2DIntBuilderWithBuffer returns a new auto-growing
// [][]int builder that wraps the provided buffer, which is never
// resliced beyond its current length.
func NewPacked2DIntBuilderWithBuffer(buf []int) *Packed2DIntBuilder {
	return &Packed2DIntBuilder{
		buf:      buf,
		autoGrow: true,
	}
}

// SetAutoGrow enables or disables auto-growing.
func (p *Packed2DIntBuilder) SetAutoGrow(t bool) {
	p.autoGrow = t
}

// Len returns the total number of elements added to finished rows and the
// active partition.
func (p *Packed2DIntBuilder) Len() int {
	return p.tail
}

// Cap returns the logical capacity of this builder. Note that this may be
// smaller than the capacity of the internal slice.
func (p *Packed2DIntBuilder) Cap() int {
	return len(p.buf)
}

// Append a single int to the current active partition. If adding this
// element would overflow the internal buffer and auto-growing is enabled, the
// current buffer is moved to a larger buffer and p.Rows is recreated before
// adding the element.
func (p *Packed2DIntBuilder) Append(x int) {
	if p.autoGrow && p.tail >= len(p.buf) {
		p.Grow(1)
	}
	p.buf[p.tail] = x
	p.tail++
}

// FinishRow appends the current active partition to p.Rows as a []int.
func (p *Packed2DIntBuilder) FinishRow() {
	p.Rows = append(p.Rows, p.buf[p.head:p.tail])
	p.head = p.tail
}

// Grow internal buffer to accommodate at least n more items.
func (p *Packed2DIntBuilder) Grow(n int) {
	// We do not check to see if n <= cap(q.a) - len(q.a) because we promised
	// never to reslice the current buffer beyond its current length.
	if n <= 0 {
		return
	}

	buf := make([]int, 1<<uint(bits.Len(uint(len(p.buf)+n-1))))
	copy(buf, p.buf[:p.tail])
	p.buf = buf

	// Recreate rows
	head, tail := 0, 0
	for i := range p.Rows {
		tail += len(p.Rows[i])
		p.Rows[i] = buf[head:tail]
		head = tail
	}
}

// Reset this Packed2DIntBuilder.
// Note that the internal buffer is NOT cleared.
func (p *Packed2DIntBuilder) Reset() {
	p.head = 0
	p.tail = 0
	p.Rows = p.Rows[:0]
}
