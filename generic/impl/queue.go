// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

// Copyright (c) 2018 Sung Pae <self@sungpae.com>
// Distributed under the MIT license.
// http://www.opensource.org/licenses/mit-license.php

package impl

import "math/bits"

// IntQueue is an auto-growing queue backed by a ring buffer.
type IntQueue struct {
	a          []int
	head, tail int
}

// DefaultIntQueueLen is the default size of a IntQueue that
// is created with a non-positive size.
const DefaultIntQueueLen = 8

// NewIntQueue returns a new queue that can accommodate at least size
// items, or DefaultQueueLen if size <= 0.
func NewIntQueue(size int) *IntQueue {
	if size <= 0 {
		size = DefaultIntQueueLen
	}
	return &IntQueue{
		a:    make([]int, 1<<uint(bits.Len(uint(size-1)))),
		head: -1,
		tail: -1,
	}
}

// Len returns the current number of queued elements.
func (q *IntQueue) Len() int {
	switch {
	case q.head == -1:
		// Queue is empty:
		//
		//	h
		//	 [_ _ _ _ _ _]
		//	t
		//
		return 0
	case q.head < q.tail:
		// Elements are in order:
		//
		//	    h
		//	 [_ 1 2 3 _ _]
		//	          t
		//
		return q.tail - q.head
	default:
		// Elements begin at rear and continue at front:
		//
		//	        h
		//	 [0 1 _ 3 4 5]
		//	      t
		//
		return len(q.a) - q.head + q.tail
	}
}

// Enqueue a new element into the queue. If adding this element would overflow
// the queue, the current queue is moved to a larger IntQueue before
// adding the element.
func (q *IntQueue) Enqueue(x int) {
	if q.tail == -1 {
		q.head = 0
		q.tail = 0
	} else if q.head == q.tail {
		q.Grow(1)
	}

	q.a[q.tail] = x

	q.tail++
	if q.tail >= len(q.a) {
		q.tail -= len(q.a)
	}
}

// EnqueueSlice adds a slice of int into the queue. If adding these
// elements would overflow the queue, the current queue is moved to a larger
// IntQueue before adding the elements.
func (q *IntQueue) EnqueueSlice(xs []int) {
	if len(xs) == 0 {
		return
	}

	newlen := q.Len() + len(xs)
	if newlen > len(q.a) {
		q.Grow(newlen - len(q.a))
	}

	switch {
	case q.head == -1:
		// Queue is empty:
		//
		//	h
		//	 [_ _ _ _ _ _]
		//	t
		//
		copy(q.a, xs)
		q.head = 0
		q.tail = len(xs)

		if q.tail >= len(q.a) {
			q.tail -= len(q.a)
		}
	case q.tail < q.head:
		// Free segment is contiguous:
		//
		//	          h
		//	 [0 _ _ _ 4 5]
		//	    t
		//
		copy(q.a[q.tail:], xs)
		q.tail += len(xs)
	default:
		// Free segment begins at rear and continues at front:
		//
		//	      h
		//	 [_ _ 2 3 _ _]
		//	          t
		//
		n := copy(q.a[q.tail:], xs)

		if n < len(xs) {
			n += copy(q.a, xs[n:])
		}

		q.tail += n
		if q.tail >= len(q.a) {
			q.tail -= len(q.a)
		}
	}
}

// Dequeue removes and returns the next element from the queue. Calling
// Dequeue on an empty queue results in a panic.
func (q *IntQueue) Dequeue() int {
	x := q.a[q.head]

	q.head++
	if q.head >= len(q.a) {
		q.head -= len(q.a)
	}

	if q.head == q.tail {
		q.Reset()
	}

	return x
}

// Peek returns the next element from the queue without removing it. Peeking
// an empty queue results in a panic.
func (q *IntQueue) Peek() int {
	return q.a[q.head]
}

// Reset the queue so that its length is zero.
// Note that the internal slice is NOT cleared.
func (q *IntQueue) Reset() {
	q.head = -1
	q.tail = -1
}

// Grow internal slice to accommodate at least n more items.
func (q *IntQueue) Grow(n int) {
	// We do not check to see if n <= cap(q.a) - len(q.a) because we'll
	// never have unused capacity.
	if n <= 0 {
		return
	}

	a := make([]int, 1<<uint(bits.Len(uint(len(q.a)+n-1))))

	switch {
	case q.head == -1:
		// Queue is empty:
		//
		//	h
		//	 [_ _ _ _ _ _]
		//	t
		q.a = a
	case q.head < q.tail:
		// Elements are in order:
		//
		//	    h
		//	 [_ 1 2 3 _ _]
		//	          t
		//
		copy(a, q.a[q.head:q.tail])
		q.a = a
		q.tail -= q.head
		q.head = 0
	default:
		// Elements begin at rear and continue at front:
		//
		//	        h
		//	 [0 1 _ 3 4 5]
		//	      t
		//
		n := copy(a, q.a[q.head:])
		n += copy(a[n:], q.a[:q.tail])
		q.a = a
		q.head = 0
		q.tail = n
	}
}

// GetSlicePointer returns a pointer to the backing slice of this IntQueue.
// *WARNING* Use at your own risk.
func (q *IntQueue) GetSlicePointer() *[]int {
	return &q.a
}

// Copyright (c) 2018 Sung Pae <self@sungpae.com>
// Distributed under the MIT license.
// http://www.opensource.org/licenses/mit-license.php

// UintQueue is an auto-growing queue backed by a ring buffer.
type UintQueue struct {
	a          []uint
	head, tail int
}

// DefaultUintQueueLen is the default size of a UintQueue that
// is created with a non-positive size.
const DefaultUintQueueLen = 8

// NewUintQueue returns a new queue that can accommodate at least size
// items, or DefaultQueueLen if size <= 0.
func NewUintQueue(size int) *UintQueue {
	if size <= 0 {
		size = DefaultUintQueueLen
	}
	return &UintQueue{
		a:    make([]uint, 1<<uint(bits.Len(uint(size-1)))),
		head: -1,
		tail: -1,
	}
}

// Len returns the current number of queued elements.
func (q *UintQueue) Len() int {
	switch {
	case q.head == -1:
		// Queue is empty:
		//
		//	h
		//	 [_ _ _ _ _ _]
		//	t
		//
		return 0
	case q.head < q.tail:
		// Elements are in order:
		//
		//	    h
		//	 [_ 1 2 3 _ _]
		//	          t
		//
		return q.tail - q.head
	default:
		// Elements begin at rear and continue at front:
		//
		//	        h
		//	 [0 1 _ 3 4 5]
		//	      t
		//
		return len(q.a) - q.head + q.tail
	}
}

// Enqueue a new element into the queue. If adding this element would overflow
// the queue, the current queue is moved to a larger UintQueue before
// adding the element.
func (q *UintQueue) Enqueue(x uint) {
	if q.tail == -1 {
		q.head = 0
		q.tail = 0
	} else if q.head == q.tail {
		q.Grow(1)
	}

	q.a[q.tail] = x

	q.tail++
	if q.tail >= len(q.a) {
		q.tail -= len(q.a)
	}
}

// EnqueueSlice adds a slice of uint into the queue. If adding these
// elements would overflow the queue, the current queue is moved to a larger
// UintQueue before adding the elements.
func (q *UintQueue) EnqueueSlice(xs []uint) {
	if len(xs) == 0 {
		return
	}

	newlen := q.Len() + len(xs)
	if newlen > len(q.a) {
		q.Grow(newlen - len(q.a))
	}

	switch {
	case q.head == -1:
		// Queue is empty:
		//
		//	h
		//	 [_ _ _ _ _ _]
		//	t
		//
		copy(q.a, xs)
		q.head = 0
		q.tail = len(xs)

		if q.tail >= len(q.a) {
			q.tail -= len(q.a)
		}
	case q.tail < q.head:
		// Free segment is contiguous:
		//
		//	          h
		//	 [0 _ _ _ 4 5]
		//	    t
		//
		copy(q.a[q.tail:], xs)
		q.tail += len(xs)
	default:
		// Free segment begins at rear and continues at front:
		//
		//	      h
		//	 [_ _ 2 3 _ _]
		//	          t
		//
		n := copy(q.a[q.tail:], xs)

		if n < len(xs) {
			n += copy(q.a, xs[n:])
		}

		q.tail += n
		if q.tail >= len(q.a) {
			q.tail -= len(q.a)
		}
	}
}

// Dequeue removes and returns the next element from the queue. Calling
// Dequeue on an empty queue results in a panic.
func (q *UintQueue) Dequeue() uint {
	x := q.a[q.head]

	q.head++
	if q.head >= len(q.a) {
		q.head -= len(q.a)
	}

	if q.head == q.tail {
		q.Reset()
	}

	return x
}

// Peek returns the next element from the queue without removing it. Peeking
// an empty queue results in a panic.
func (q *UintQueue) Peek() uint {
	return q.a[q.head]
}

// Reset the queue so that its length is zero.
// Note that the internal slice is NOT cleared.
func (q *UintQueue) Reset() {
	q.head = -1
	q.tail = -1
}

// Grow internal slice to accommodate at least n more items.
func (q *UintQueue) Grow(n int) {
	// We do not check to see if n <= cap(q.a) - len(q.a) because we'll
	// never have unused capacity.
	if n <= 0 {
		return
	}

	a := make([]uint, 1<<uint(bits.Len(uint(len(q.a)+n-1))))

	switch {
	case q.head == -1:
		// Queue is empty:
		//
		//	h
		//	 [_ _ _ _ _ _]
		//	t
		q.a = a
	case q.head < q.tail:
		// Elements are in order:
		//
		//	    h
		//	 [_ 1 2 3 _ _]
		//	          t
		//
		copy(a, q.a[q.head:q.tail])
		q.a = a
		q.tail -= q.head
		q.head = 0
	default:
		// Elements begin at rear and continue at front:
		//
		//	        h
		//	 [0 1 _ 3 4 5]
		//	      t
		//
		n := copy(a, q.a[q.head:])
		n += copy(a[n:], q.a[:q.tail])
		q.a = a
		q.head = 0
		q.tail = n
	}
}

// GetSlicePointer returns a pointer to the backing slice of this UintQueue.
// *WARNING* Use at your own risk.
func (q *UintQueue) GetSlicePointer() *[]uint {
	return &q.a
}
